


Functional Programming is a form of declarative programming. Each item can be run in any order to produce the same result.
Imperative Programming is procedural. State and order is important.


Java 8
----------
New Features:
		Lambda Expression
		Stream API
		Default methods in the interface
		Functional Interface
		Optional
		Method references
		Date API
		Nashorn, JavaScript Engine

Lambda Expression: 		
A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not 
need a name and they can be implemented right in the body of a method.

Lambda Expression is just an anonymous(nameless) function. That means the function which doesn’t 
have the name,return type and access modifiers.
Lambda Expression also known as anonymous functions or closure

Remember, lambdas should be an expression, not a narrative. Despite its concise syntax, lambdas should specifically express the functionality they provide.

why lambdas?
  Enables functional programming
  Readable and concise code.
  Easier to use APIs and libraries
  Enables support for parallel processing.
  A function that can be created without belonging to any class.
  A lambda expression can be passed around as if it was an object and executed on demand.
  
Lambda expression   
aBlockOfCode = () -> {
 System.out.println();
}
greetFunction = () -> Syso("Hello World");
getSumOfTwoNumber = (a) -> {a+8};  
(for one line of code, we can remove the curly bracket)
Avoid Specifying Parameter Types like (int a)
Avouid return and braces.

Functional Interfaces:
------------------------------
if an interface contain only one abstract method, such type of interfaces are called functional 
interfaces and the method is called functional method or single abstract method(SAM).
Ex:
1) Runnable  It contains only run() method
2) Comparable  It contains only compareTo() metho
3) ActionListener  It contains only actionPerformed()
4) Callable  It contains only call()method

4 types of functional interface.
Consumer => accept(T t) => accepts single input and returns no result.
Supplier => T get() => accepts no input but returns a result
Predicate => test() It return boolean value. (stream.filter method)
Function. => apply() It return one value of any type. (stream.map method)




Inside functional interface in addition to single Abstract method(SAM) we write any number of 
default and static methods.
Ex:
1) interface Interf { 
2) public abstract void m1(); 
3) default void m2() { 
4) System.out.println (â€œhelloâ€ ); 
5) } 
6) } 
In Java 8 ,SunMicroSystem introduced @FunctionalInterface annotation to specify that the interface is 
FunctionalInterface.

Ex: 
@FunctionalInterface
Interface Interf { this code compiles without any compilation errors.
 public void m1();
 }
 
Predicate:
---------------
A predicate is a function with a single argument and returns boolean values


Ex:
interface Predicate<T> {
 public boolean test(T t);
}
As predicate is a functional interface and hence it can refers lambda expression.

It has  below default method.
and()
or()
negate(
 
 
Write a predicate to check whether the given integer is greater than 10 or not.
Ex:
public boolean test(Integer I) {
 if (I >10) {
 return true;
 }
 else {
 return false;
 }
}

TO:

predicate<Integer> p = I -> (I >10);
System.out.println (p.test(100)); true
System.out.println (p.test(7)); false

Function:
-------------
Functions are exactly same as predicates except that functions can return any type of result.

Function can take 2 type Parameters.first one represent Input argument type and Second one represent return Type. 
Function<T,R>

interface function(T,R) {
 public R apply(T t);
}

Assignment:
Write a function to find length of given input string.
Ex:
1) import java.util.function.*; 
2) class Test { 
3) public static void main(String[] args) { 
4) Function<String, Integer> f = s ->s.length(); 
5) System.out.println(f.apply("Durga")); 
6) System.out.println(f.apply("Soft")); 
7) } 
8) }
 
 
 
 
 Interface static method: we should call interface static methods by using interface name not using class or object name.
 
 From 1.8 version onwards we can write main()method inside interface and hence we can run interface 
directly from the command prompt.
Ex:
1) interface Interf { 
2) public static void main(String[] args) { 
3) System.out.println("Interface Main Method"); 
4) } 
5) } 

java.util.Optional
--------------
Java 8 documentation says that an Optional is "A container object which may or may not contain a non-null value. 
If a value is present, isPresent() will return true and get() will return the value."

purpose
----------
Optional is intended to provide a limited mechanism for library method return types where there is a clear need to represent "No result"
and where using null for that is overwhelmingly likely to cause errors.

Optional class basically help us to avoid writing null check and avoid NullPointerException. 
Optional makes us deal with nullable values explicitly as a way of enforcing good programming practices.
You can view Optional as single-value container that either contains a value or doesn't (it is then said to be "empty"). 
But for sure it won't throw NullPointerException.

Advantages
---------
Null checks are not required.
No more NullPointerException at runtime.
we can develop clean and neat API
No more boiler plate code.
To avoid abnormal termination, we use the Optional class. 

Optional.Of(str) // the argument should not allow null value otherwise it'll throw NullPointerException.
optional.ofNullable(str) // the argument can allow null value. it'll not throw NullPointerException rather returns empty Optional object.

id Name
1  test
2  test2
3  Null
4  Null

String b = null;
Optional<String> s = Optional.Empty(); // same as above stmt. s=null
Optional<String> s = null // It Cannot be NULL.

get() can only return a value if the wrapped object not null, otherwise it will throw NoSuchElementException
(e.g): Employee e = repo.findById(id).get(); // if we pass id which is not available in db.

hence we should call get() method by conditioning it using isPresent()

Optional<String> optionalStr = Optional.ofNullable(str);
optionalStr.ifPresent(s -> System.out.println(s.length()));


Optional<Employee> e = repo.findById(id);
if(e.isPresent()) {
  Optional<String> empName = Optional.ofNullable(e.get().getName())
  if(empName.isPresent()) {
     return new ResponseEntity
  return new ResponseEntity<>(e.get(), HttpStatus.OK)
} else {
  return new ResponseEntity<>("Sorry employee with the give id is not found", HttpStatus.NOT_FOUND)
  }
  
orElse(default) // opt.map(Customer::getName).orElse("Unknown")
orElseGet(supplier) // opt.orElseGet(Data::new)
orElseThrow(exceptionSupplier)// opt.orElseThrow(IllegalArumentException::new)
 
Avoid using Optional in
1) Fields
2) Method Parameters 
3) COllections

Remember eliminating nulls isn't a goal of Optional.

https://www.oracle.com/technical-resources/articles/java/java8-optional.html
https://javarevisited.blogspot.com/2017/04/10-examples-of-optional-in-java-8.html#axzz7QLAEHs9j
https://homes.cs.washington.edu/~mernst/advice/nothing-is-better-than-optional.html
https://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html

https://www.youtube.com/watch?v=hjIlTaAMsbI&ab_channel=ContinuousDelivery (explore)
https://www.youtube.com/watch?v=salqMzVPopM&ab_channel=ITian


what is stream
-------------------

the Stream API is used to process collections of objects. 
A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result.

The features of Java stream are –

1) A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.
2) Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
3) Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined.
 Terminal operations mark the end of the stream and return the result.
 
 
intermediate operation (filter, map etc) to convert to abstract type
terminal operation (COllect, min, max,forEach, reduce, group by etc) to convert to concreate type
(entire stream operation will work only we have terminal operation in it) therefore stream is called as Lazy valuation

DIfferent ways to create streams
1) Stream.of(val1, val2,..)
2) Stream.of(arrayOfElement) Stream.of(new Integer[]{1,2,3})
3) List.stream
4) Arrays.stream(T[])



Three ways to get the duplicate elements.

1) Filter & Set.add()  [ Set.add() returns false if the element was already in the set.]
list.stream().filter(n -> !items.add(n)).collect(Collectors.toSet());

2) Map & Collectors.groupingBy

return list.stream()
                .collect(Collectors.groupingBy(Function.identity()
                        , Collectors.counting()))    // create a map {1=1, 2=1, 3=2, 4=2, 5=1, 7=1, 9=2}
                .entrySet().stream()                 // Map -> Stream
                .filter(m -> m.getValue() > 1)       // if map value > 1, duplicate element
                .map(Map.Entry::getKey)
                .collect(Collectors.toSet());
				
3) Collections.frequency
list.stream().filter(i -> Collections.frequency(list, i) > 1).collect(Collectors.toSet());


map vs flatMap
--------------------
map: Transforms each element into another element.
One-to-one (each element maps to a single element).
Output will be Stream of transformed elements.
Example: Squaring numbers in a list: [1, 2, 3] → [1, 4, 9].

List<Integer> numbers = Arrays.asList(1, 2, 3);
List<Integer> squared = numbers.stream().map(n -> n * n).collect(Collectors.toList());
// Output: [1, 4, 9]


flapMap: 
Transforms each element into a stream and flattens the streams.
One-to-many (each element maps to a stream of elements).
Output will be Flattened stream of elements.
Example: Flattening a list of lists: [[1, 2], [3, 4]] → [1, 2, 3, 4].

List<List<Integer>> lists = Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4));
List<Integer> flattened = lists.stream().flatMap(List::stream).collect(Collectors.toList());
// Output: [1, 2, 3, 4]


comparingByKey and comparingByValue and reverseOrder for key and value.
------------------------------------------------------
 .sorted(Map.Entry.comparingByKey(Comparator.reverseOrder()))  (replace it like this)

Map<Integer,String> map=new HashMap<Integer,String>();          
      map.put(100,"Amit");    
      map.put(101,"Vijay");    
      map.put(102,"Rahul");   
      //Returns a Set view of the mappings contained in this map        
      map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByKey())  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  
 }
 
100=Amit
101=Vijay
102=Rahul 
 
Map<Integer,String> map=new HashMap<Integer,String>();          
      map.put(100,"Amit");    
      map.put(101,"Vijay");    
      map.put(102,"Rahul");    
      //Returns a Set view of the mappings contained in this map    
      map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByValue())  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  
 }  
100=Amit
102=Rahul
101=Vijay 









Use Java's Consumer interface to store a lambda expression in a variable:
public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(5);
    numbers.add(9);
    numbers.add(8);
    numbers.add(1);
    Consumer<Integer> method = (n) -> { System.out.println(n); };
    numbers.forEach( method );
  }
  
  
  
List<Product>productsList = new ArrayList<Product>();  
        //Adding Products  
        productsList.add(newProduct(1,"HP Laptop",25000f));  
        productsList.add(newProduct(2,"Dell Laptop",30000f));  
        productsList.add(newProduct(3,"Lenevo Laptop",28000f));  
        productsList.add(newProduct(4,"Sony Laptop",28000f));  
        productsList.add(newProduct(5,"Apple Laptop",90000f));  

Set<Float>productPriceList =   
                productsList.stream()  
                            .map(x->x.price)         // fetching price  
                            .collect(Collectors.toSet());   // collecting as list  
        System.out.println(productPriceList);
		
Java Collectors Example: using sum and average method
------------------------------------------------------------
 Double sumPrices =   
                productsList.stream()  
                            .collect(Collectors.summingDouble(x->x.price));  // collecting as list  
        System.out.println("Sum of prices: "+sumPrices);  
Integer sumId =   
		productsList.stream().collect(Collectors.summingInt(x->x.id));  
System.out.println("Sum of id's: "+sumId);  
		
Double average = productsList.stream()  
                         .collect(Collectors.averagingDouble(p->p.price));  
        System.out.println("Average price is: "+average);  		
		
		
Stream Processing -
___________________________________________________________________________

Collect - 
If we want to collect elements of stream after filtering or mapping and add them to the required collection then use collect method.

Count - 
If we want to count how many elements are there in collection that satisfy given condition then use count method.

sorted - 
If we want to sort elements inside a stream use this sorted() method.
We can sort based on default natural sorting order 
If we want to sort using customized sorting order then use comparator.

Comparator 
If we want to sort using customized sorting order then use comparator.

Min Max-
Min(Comparator)  will return the minimum value based on the defined comparator
Max(Comparator)  will return the maximum value based on the defined comparator

Foreach
forEach() is a method . 
All methods that we saw till now returned something, like min max value, sorted collection, etc
This method does not return anything. 
Rather This method takes lambda expression as argument and apply that lambda expression to each element present in that stream.

toArray- 

of() - 
Stream concept is not applicable just for the collections it’s also applicable for “ANY GROUP OF VALUE”.
Even for arrays you can use stream.
Stream . Of() this method can take any group of values and convert them to stream so that multiple stream operations can be applied to it.		

Stream with sorted(), min and max
sorted
----------
If we want to sort elements inside a stream use this sorted() method.
We can sort based on default natural sorting order 
If we want to sort using customized sorting order then use comparator.

filteredStream.sorted((i1, i2) -> i1.compareTo(i2))  // ascending or natural sorting
filteredStream.sorted((i1, i2) -> i2.compareTo(i1))  // descending

Min Max
------------
If we want to sort using customized sorting order then use comparator.

Min Max-
Min(Comparator)  will return the minimum value based on the defined comparator
Max(Comparator)  will return the maximum value based on the defined comparator

arrList.stream().min((i1, i2) -> i1.compareTo(i2)).get();
arrList.stream().max((i1, i2) -> i1.compareTo(i2)).get();

toArray()
-----------
Always return Object[].
Object[] intArr = arrList.stream().filter(i -> i>2).toArray();

Integer[] ir = l1.stream().toArray(Integer[] :: new);
for(Integer i: ir) {
 sop(i);
 }

Of()
---------
Stream concept is not applicable just for the collections it’s also applicable for “ANY GROUP OF VALUE”.
Even for arrays you can use stream.
Stream . Of() this method can take any group of values and convert them to stream so that multiple stream operations can be applied to it.	

Stream.of(1,11,111,1111,11111).forEach(System.out::println());

String[] name = {"Test", "Code", "Stream"};
Stream.of(name).filter(x-> x.length >2).forEach(System.out::println())

Java StringJoiner
---------------------
Java added a new final class StringJoiner in java.util package. It is used to construct a sequence of characters separated by a delimiter.
 Now, you can create string by passing delimiters like comma(,), hyphen(-) etc. You can also pass prefix and suffix to the char sequence.

 public static void main(String[] args) {  
        StringJoiner joinNames = new StringJoiner(","); // passing comma(,) as delimiter   
          
        // Adding values to StringJoiner  
        joinNames.add("Rahul");  
        joinNames.add("Raju");  
        joinNames.add("Peter");  
        joinNames.add("Raheem");  
                  
        System.out.println(joinNames);  
    }  
	
	Output: Rahul,Raju,Peter,Raheem
	
	
	
Java 9 features.
------------------
Oracle has released Java 9 with rich set of new features. It includes various upgrades to the Java programming, JVM, Tools and libraries

1) Platform Module System (Project Jigsaw)
Java Module System is a major change in Java 9 version. Java added this feature to collect Java packages and code into a single unit called module.
In earlier versions of Java, there was no concept of module to create modular Java applications, that why size of application 
increased and difficult to move around. Even JDK itself was too heavy in size, in Java 8, rt.jar file size is around 64MB.

To deal with situation, Java 9 restructured JDK into set of modules so that we can use only required module for our project.

2) Interface Private Methods
In Java 9, we can create private methods inside an interface. Interface allows us to declare private methods that help to share common code between non-abstract methods.
	
3) JShell: The Java Shell (REPL)
It is an interactive Java Shell tool, it allows us to execute Java code from the shell and shows output immediately. JShell is a REPL (Read Evaluate Print Loop) tool and run from the command line. It is benificial, if we want to test our business logic and get result immediately. 	
	
