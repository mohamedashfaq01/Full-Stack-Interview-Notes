Java 7 Features
------------------
1) Switch With String (case sensitive)

2) Java 7 Multi Catch. (It helps to optimize code, using use vertical bar (|) to separate multiple exceptions in catch block.
     catch(ArithmeticException | ArrayIndexOutOfBoundsException e){  
            System.out.println(e.getMessage());  
        }    
		
3) Binary Literals (I allows you to express integral types (byte, short, int, and long) in binary number system. To specify a binary literal, add the prefix 0b or 0B to the integral value.)
 int i1 = -0b101;   		// prints -5
 long l1 = 0b0000011111100001; // prints 2017
 
4)  Type Inference for Generic Instance Creation

The following approach is used in Java 6 and prior version.

Ex. List<Integer> list  = new List<Integer>();  
Now, you can use the following new approach introduced in Java 7.

Ex. List<Integer> list = new List<>(); // Here, we just used diamond 

5) Java Numeric Literals with Underscore (Ot improves the readability of source code).

    int a = 10_00000;  
	System.out.println("a = "+a);  
	// Underscore in floating literal  
	float b = 10.5_000f;  
	System.out.println("b = "+b);  

Java 5 Features
--------------
1) Assertion
2) Autoboxing and unboxing
The automatic conversion of primitive data types into its equivalent Wrapper type is known as boxing and opposite operation is known as unboxing.
int -> Integer (Boxing)
Integer -> int (Unboxing)
	 int a=30;
	 Integer a3=a;//Boxing  
	 
3) Java Enums
The Enum in Java is a data type which contains a fixed set of constants.

It can be used for days of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY) , directions (NORTH, SOUTH, EAST, and WEST), season (SPRING, SUMMER, WINTER, and AUTUMN or FALL)
	 class EnumExample1{  
		//defining the enum inside the class  
		public enum Season { WINTER, SPRING, SUMMER, FALL }  
		//main method  
		public static void main(String[] args) {  
		//traversing the enum  
		for (Season s : Season.values())  
		System.out.println(s);  
	}}  

4) Java Annotation ( represents the metadata, to indicate some additional information which can be used by java compiler and JVM.)

5) Generics in Java : It makes the code stable by detecting the bugs at compile time.
List<Integer> list = new ArrayList<Integer>();    

6) For-Each loop
It makes the code more readable.
It eliminates the possibility of programming errors.
int arr[]={12,13,14,44};  
   //traversing the array with for-each loop  
   for(int i:arr){  
     System.out.println(i);  
   }  
   
7) Java Static Import
-----------------------------
The static import feature of Java 5 facilitate the java programmer to access any static member of a class directly.
 There is no need to qualify it by the class name.

import static java.lang.System.*;    
class StaticImportExample{  
  public static void main(String args[]){  
     
   out.println("Hello");//Now no need of System.out  
   out.println("Java");  
  
 }   
}      
   
   
8) Variable Argument (Varargs):
The varrags allows the method to accept zero or muliple arguments. 
If we don't know how many argument we will have to pass in the method, varargs is the better approach.

Rules for varargs:
	There can be only one variable argument in the method.
	Variable argument (varargs) must be the last argument.

	void method(String... a, int... b){}//Compile time error  
	void method(int... a, String b){}//Compile time error     

class VarargsExample3{  
   
 static void display(int num, String... values){  
  System.out.println("number is "+num);  
  for(String s:values){  
   System.out.println(s);  
  }  
 }  
  
 public static void main(String args[]){  
  
 display(500,"hello");//one argument   
 display(1000,"my","name","is","varargs");//four arguments  
 }   
} 


ClassCast Exception in TreeSet
If we add an object of the class that is not implementing the Comparable interface, the ClassCast Exception is raised. Observe the following program.

Shallow Copy and Deep Copy
--------------------------------

Shallow Copy: Copies the object's fields and references, but Original and copy share the same references, Less memory usage.
In Person class: implements cloneable
// Method to create a shallow copy
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
	(Only in person class, we'll not implement cloneable in address class).
	

Deep Copy: Copies the object's fields and references, but Original and copy share the different references, Moremoemory Usage.
In Person class: implements cloneable
// Method to create a deep copy of Person
protected Object clone() throws CloneNotSupportedException {
	Person cloned = (Person) super.clone();
	cloned.address = (Address) address.clone(); // Create a deep copy of Address
	return cloned;
}

In Address Class: implements cloneable
 // Method to create a deep copy of Address
protected Object clone() throws CloneNotSupportedException {
	return super.clone();
}

wait, notify, notifyall exists in Object class But we use only in multithread right. 
then those method we keep it inside the thread class right why it's exist in Object 
class?

The methods wait(), notify(), and notifyAll() are in the Object class because synchronization and thread coordination in Java
 are designed to work with the intrinsic locks associated with objects, not just threads. 
This design provides flexibility, allowing any object to be used as a lock for synchronizing access to shared resources.


Name few sorting algorithms and search algorithms
--------------------------------------------------------

Sorting Algorithms
Bubble Sort
Selection Sort
Insertion Sort
Merge Sort
Quick Sort


Search Algorithms
Linear Search
Binary Search
Depth-First Search (DFS)
Breadth-First Search (BFS)

what algorithm garbage collector uses. 
---------------------------------------------
Different garbage collection algorithms are used in Java to manage memory efficiently. 
The choice of algorithm can impact the performance of your application, and each has its own strategy for marking, sweeping, and compacting memory.

Algorithms Used by Garbage Collectors

Mark and Sweep
Concurrent Mark and Sweep (CMS)
Generational Garbage Collection
Reference Counting
G1 (Garbage-First) Collector

Mark and Sweep Algorithm
------------------------------
The Mark-and-Sweep algorithm is a simple method used by garbage collectors to clean up unused memory in programming languages like Java.

Imagine a toy box with various toys:

Toys in the Box:

Toy A (favorite toy, used every day)
Toy B (connected to Toy A, like a toy car that goes with a toy track)
Toy C (not connected to Toy A or B, like a random toy in the corner)

Mark Phase:
Start by marking Toy A because it's your favorite (root object).
Toy B is connected to Toy A, so you also mark Toy B.
You ignore Toy C for now because it's not connected to Toy A.

Sweep Phase:
Look at each toy and check if it's marked.
Toy A and Toy B are marked, so you keep them.
Toy C is not marked, so you put it away or throw it out.

The Mark-and-Sweep algorithm helps in cleaning up memory by marking useful objects (toys) and then sweeping away the unused ones.
 It ensures that your memory (toy box) is tidy and only contains the things you need.

The Mark-and-Sweep algorithm helps to manage memory by:

Marking: Identifying and marking the memory that is still needed.
Sweeping: Cleaning up the memory that is no longer needed.



ConcurrentModificationException
-----------------------------------

Fail-fast and Fail-safe Iterators.

In Java, the terms fail-fast and fail-safe refer to the behavior of iterators when the underlying collection is modified during iteration. 
These behaviors are crucial in concurrent programming and help ensure the integrity of collections during modification.

Fail-Fast Iterators:

Fail-fast iterators immediately throw a ConcurrentModificationException if they detect any structural modification of the collection during iteration. 
Structural modification refers to any operation that adds, removes, or changes the size of the collection.

Examples of Fail-Fast Collections:
ArrayList
HashMap
HashSet
LinkedList.

Fail-Safe Iterators: 
Fail-safe iterators do not throw ConcurrentModificationException if the collection is modified during iteration. Instead, they work on a clone of the collection,
 which ensures that any changes to the collection do not affect the iterator.

Examples of Fail-Safe Collections:
CopyOnWriteArrayList
ConcurrentHashMap

ConcurrentModificationException is a runtime exception that occurs when a collection (like ArrayList, HashMap, etc.) 
is modified while iterating over it using methods like Iterator or enhanced for loop

List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        for (String item : list) {
            if ("B".equals(item)) {
                list.remove(item); // This will throw ConcurrentModificationException
            }
        }
		
Overcome:
1) Using Iterator's remove Method:
while (iterator.hasNext()) {
            String item = iterator.next();
            if ("B".equals(item)) {
                iterator.remove(); // Safe removal
            }
        }
		
2) Using CopyOnWriteArrayList for Concurrent Collections:		

List<String> list = new CopyOnWriteArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        for (String item : list) {
            if ("B".equals(item)) {
                list.remove(item); // Safe removal
            }
        }		
Is Java pass by value or pass by reference why
---------------------------------------------------
Java uses pass-by-value for all types, including both primitive types and object references.
For primitives, this means passing a copy of the value.
For objects, this means passing a copy of the reference to the object, so while the reference is copied, the object it points to can be modified.

As the name says, the pass-by-value simply means, we pass the value of the variable(or reference variable) and not the address of the variable
(or reference variable) from the main function to the called function.		
		
		
Java 11 and Java 17 feature.
--------------------------------

Java 11:
 HttpClient for modern HTTP requests.
String methods like strip() and isBlank(), repeat(2).	

Java 17:
Text blocks for easier multiline string literals.
String json = """
    {
      "name": "John",
      "age": 30
    }
""";
	
ClassNotFoundException vs NoClassDefFoundError 
------------------------------------------------------
ClassNotFoundException:
Checked exception thrown when an application tries to load a class at runtime and the class is not found.
Needs to be handled with a try-catch block or declared in the throws clause.

Checked Exception.
try {
	// Attempt to load a class dynamically
	Class.forName("com.example.NonExistentClass");
} catch (ClassNotFoundException e) {
	// Handle the exception
	System.out.println("ClassNotFoundException caught: " + e.getMessage());
}


NoClassDefFoundError: 

Occurs when a class was present during the compile time but is not found during runtime due to various reasons 
like deletion or not being available in the classpath.

like somebody has deleted that sample.class file after the compilation.

Unchecked error.

	

When to Use Callable vs. Runnable
------------------------------------
The Callable interface provides more functionality compared to Runnable by allowing tasks to return results and throw checked exceptions. 
This makes Callable more suitable for tasks where you need a result or need to handle exceptions, while Runnable is appropriate for simpler,
 fire-and-forget tasks.

Use Callable when you need:
A task that returns a result.
A task that can throw checked exceptions.

Use Runnable when you:
Do not need to return a result.
Do not need to throw checked exceptions. 


there are several ways to create and manage threads.
1) . Extending the Thread Class
2. Implementing the Runnable Interface
3. Implementing the Callable Interface
4. Using the ExecutorService Framework
5.Using the ForkJoinPool Framework
Suitable for parallel processing and recursive task division.
(The ForkJoinPool framework is designed for work that can be broken into smaller tasks and is suitable for divide-and-conquer algorithms.)


Implementing the Callable Interface
--------------------------------------
Callable is similar to Runnable but can return a result and throw a checked exception.

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        return 123;
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MyCallable myCallable = new MyCallable();
        Future<Integer> future = executor.submit(myCallable);
        
        try {
            Integer result = future.get(); // Get the result of the Callable
            System.out.println("Result: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}

4. Using the ExecutorService Framework
-------------------------------------------
The ExecutorService framework provides a higher-level replacement for working with threads directly. 
It manages a pool of threads and provides various methods for executing tasks asynchronously.

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);

        Runnable task = new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread is running");
            }
        };

        for (int i = 0; i < 10; i++) {
            executor.execute(task); // Submit tasks to the executor
        }

        executor.shutdown(); // Initiates an orderly shutdown
    }
}

Java Thread Pool
--------------------
Java Thread pool represents a group of worker threads that are waiting for the job and reused many times.

In the case of a thread pool, a group of fixed-size threads is created. A thread from the thread pool is pulled out 
and assigned a job by the service provider. After completion of the job, the thread is contained in the thread pool again.

Callable and Future
------------------------
Callable: 

Definition: Callable is a functional interface that represents a task that can be executed asynchronously and returns a result. It can throw checked exceptions.
Return Type: Returns a result of type V when the task is completed.
Usage: Use Callable when you need a task that computes a result and may throw checked exceptions.
Example:

import java.util.concurrent.Callable;

public class CallableExample {
    public static void main(String[] args) throws Exception {
        Callable<Integer> task = () -> {
            // Simulate some computation
            return 123;
        };
        Integer result = task.call();
        System.out.println("Result: " + result);
    }
}

Future:

Definition: Future is an interface that represents the result of an asynchronous computation. It provides methods to check if the computation is complete,
 wait for its completion, and retrieve the result.
 
Usage: Use Future to retrieve the result of a Callable task that was submitted to an executor service, check its status, or cancel it. 

Example:
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutorService;

public class FutureExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Callable<Integer> task = () -> {
            // Simulate some computation
            return 123;
        };
        
        Future<Integer> future = executor.submit(task);
        
        // Get the result of the computation
        Integer result = future.get(); // This will block until the result is available
        
        System.out.println("Result: " + result);
        
        executor.shutdown();
    }
}

In summary, Callable is used to define tasks, while Future is used to manage and retrieve the results of those tasks.

How To handle 1000 transactions using 100 threads efficiently,
--------------------------------------------------------
To handle 1000 transactions using 100 threads efficiently, we use Javaâ€™s ExecutorService. 
First, we define a Runnable task that simulates transaction processing. 
Then, we create a thread pool with Executors.newFixedThreadPool(100), which manages 100 threads. 
We submit 1000 transaction tasks to this pool, which handles task execution concurrently. Finally,
 we shut down the executor service with shutdown() and wait for task completion using awaitTermination().
 
 This approach optimizes resource usage, ensures efficient task handling, and
 prevents excessive thread creation, providing a scalable solution for processing multiple transactions.
 
create Own executor service for pooling of threads which data structure to use
------------------------------------------------------------------------------------
Steps to Create a Custom ExecutorService
Define the ExecutorService Interface: Create an interface similar to ExecutorService that outlines methods for submitting tasks and shutting down the service.

Implement the Thread Pool: Develop a class that implements the custom executor service, managing a pool of worker threads.

Use a Suitable Data Structure: Utilize a BlockingQueue to manage the tasks. Commonly used implementations include "LinkedBlockingQueue" and "ArrayBlockingQueue".

Manage Threads: Create worker threads that continuously fetch and execute tasks from the queue. 
 

Executor Framework Java
----------------------------
In order to manage worker threads efficiently 	we use Executor Framwork.
The executor framework is an implementation of the Producer-Consumer pattern. 
The java.util.concurrent.Executors class provides a set of methods for creating ThreadPools of worker threads.

In order to use the executor framework, we have to create a thread pool for executing the task by submitting that task to that thread pool.

Types Of executors.

1) SingleThreadExecutor
The SingleThreadExecutor is a special type of executor that has only a single thread. It is used when we need to execute tasks in sequential order.
ExecutorService executor = Executors.newSingleThreadExecutor()  


2) FixedThreadPool(n)
FixedThreadPool is another special type of executor that is a thread pool having a fixed number of threads. By this executor, the submitted task is executed 
by the n thread.
ExecutorService executor = Executors.newFixedThreadPool(4);  

3) CachedThreadPool
The CachedThreadPool is a special type of thread pool that is used to execute short-lived parallel tasks. 
The cached thread pool doesn't have a fixed number of threads. 
ExecutorService executor = Executors.newCachedThreadPool();

4) ScheduledExecutor
The ScheduledExecutor is another special type of executor which we use to run a certain task at regular intervals. 
It is also used when we need to delay a certain task.
ScheduledExecutorService scheduledExecService = Executors.newScheduledThreadPool(1);  

The scheduleAtFixedRate and scheduleWithFixedDelay are the two methods that are used to schedule the task in ScheduledExecutor

The scheduleAtFixedRate method executes the task with a fixed interval when the previous task ended.
The scheduleWithFixedDelay method starts the delay count after the current task complete.


Thread pools offer significant advantages in terms of resource management, performance, task scheduling, concurrency handling, and ease of use. 

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5); // Creating a pool of 5 threads
        
        for (int i = 0; i < 10; i++) {
            Runnable worker = new WorkerThread("" + i);
            executor.execute(worker); // Submitting tasks to the executor
        }
        
        executor.shutdown(); // Initiates an orderly shutdown
        try {
            // Waits for all tasks to complete or the timeout to occur
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                executor.shutdownNow(); // Forces shutdown if tasks are not completed
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
}

class WorkerThread implements Runnable {
    private String command;
    
    public WorkerThread(String s) {
        this.command = s;
    }
    
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " Start. Command = " + command);
        processCommand();
        System.out.println(Thread.currentThread().getName() + " End.");
    }
    
    private void processCommand() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
