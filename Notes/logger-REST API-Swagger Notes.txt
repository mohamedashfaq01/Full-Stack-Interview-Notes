

Spring-boot-starter-web dependency internally uses spring-boot-starter-logging dependency.
Hence logging automatically comes in springboot.

@Slf4j is an interface, 

Logback Project
Logback is intended as a successor to the popular log4j project, 

REST-API
---------------



Idempotency ensures that performing an operation multiple times has the same effect as performing it once. This is important in transaction management to avoid duplicate transactions, maintain data consistency, and ensure the reliability of systems,
especially in the face of network issues or other glitches.

This concept is important for ensuring that repeated HTTP requests, often due to network issues or retries, do not produce unintended effects.


Simple Analogy: Pressing a Button:
--------------------------------------

Imagine you have a button that orders a pizza. When you press the button once, it sends an order to the pizza shop. Now, let's say your internet connection is a bit slow,
 and you're not sure if the order went through, so you press the button again.

Without Idempotency: Every time you press the button, a new order is sent. So, if you press it three times, you'll get three pizzas.
With Idempotency: No matter how many times you press the button, only one order is sent. So, if you press it three times, you'll still get just one pizza.


Idempotent Operations: GET, PUT, DELETE

POST Requests: Typically, POST requests are not idempotent.
 They often create new resources or trigger operations that change the state on the server, so repeating the request can lead to duplicate resources or actions.
 
POST vs PUT
-----------------
POST: Preferred for creating new resources where the server determines the URI. It is not idempotent, allowing for the creation of multiple resources with repeated requests.

POST /users
{
  "name": "John Doe",
  "email": "john.doe@example.com"
} 
Server: Generates a new user ID and returns the location of the new resource.
Response: 201 Created


PUT: Best suited for updating or replacing existing resources where the client knows the URI. It is idempotent, meaning repeated requests have the same effect.

PUT /users/123
{
  "name": "John Doe",
  "email": "john.doe@example.com"
}

Client: Specifies the URI of the resource to update.
Server: Updates the resource at /users/123.


Technically speaking, you can use POST for update operation and PUT for create operation, but this would be against the recommended convention for RESTful APIs.
However, it is important to note that these are just conventions and not strict rules. why

HTTp Status
-----------------
200	OK	Successful
201	Created	Successful
202	Accepted	Successful
204	No Content	Successful

400	Bad Request	Client Error
401	Unauthorized	Client Error
403	Forbidden	Client Error
404	Not Found	Client Error
405	Method Not Allowed	Client Error

500	Internal Server Error	Server Error
501	Not Implemented	Server Error
502	Bad Gateway	Server Error
503	Service Unavailable	Server Error
504	Gateway Timeout	Server Error

Example of endpoints formation
--------------------------------
Here are some example endpoints for a fictional e-commerce microservice:

List all products:

GET /products
Get a specific product:

GET /products/{productId}
Create a new product:

POST /products
Update a specific product:

PUT /products/{productId}
Delete a specific product:

DELETE /products/{productId}
List orders for a user:

GET /users/{userId}/orders
Get a specific order:

GET /orders/{orderId}
Filter products by category:

GET /products?category=electronics
Sort products by price:

GET /products?sort=price



















Swagger
------------
It is Open source API documentation framework to help developers in design, document and consume RESTful web services.
It is most popular tool for generating interactive documentation from API.
Spring Boot makes developing RESTful services ridiculously easy â€” and using Swagger makes documenting your RESTful services easy.

Testing of Web API is always a challenge because they expose their end-points rather than UI. Swagger resolves this issue by providing UI
 representation of the RESTful APIs.

Swagger generates UI using the Swagger specification file (swagger.json) that is generated by Swagger tool based on service code.

Why Swagger configurations/documentation

- It gives self explantory information about all APIs developed / available
- Easy to use for testing
- Provides more description to use APIs than postman
- Clean user interface to APIs
- We can generate swagger/api documentation easily

To enable the Swagger2 in Spring Boot application, you need to add the following dependencies in our build configurations file.

<dependency>
   <groupId>io.springfox</groupId>
   <artifactId>springfox-swagger2</artifactId>
   <version>2.7.0</version>
</dependency>

<dependency>
   <groupId>io.springfox</groupId>
   <artifactId>springfox-swagger-ui</artifactId>
   <version>2.7.0</version>
</dependency>

URL for Swagger API User Interface
http://localhost:8080/swagger-ui.html

URL for Swagger API Docs Json
http://localhost:8080/v2/api-docs

Hide Endpoints from Swagger Documentation: 
@ApiIgnore
@GetMapping("/getUser")

hide all endpoints of a controller class, apply the @ApiIgnore annotation at class level.
@ApiIgnore
@RestController

To give more description about the model class. we use @ApiModel and @ApiModelProperty

@ApiModel(description="Details About products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @ApiModelProperty(notes = "The database generated product ID")
    private Integer id;



Swagger uses so many annotation for detailing which leads to Annotation Hell problem. This annotation is more than the actual code itself 
Hence to solve this issue Spring REST Docs comes into picture.

"C:/Program Files/Google/Chrome/Application/chrome.exe" --user-data-dir="C:/Chrome dev session" --disable-web-security




 

